use crate::vision::server::{detect_image_mime, MAX_UPLOAD_SIZE};
use proptest::prelude::*;

// ── Strategies ──────────────────────────────────────────────

/// Generate valid image bytes with a proper magic header.
/// All generated bytes have length >= 4 to pass the length check in detect_image_mime.
fn arb_image_bytes() -> impl Strategy<Value = (Vec<u8>, &'static str)> {
    prop_oneof![
        // PNG: 89 50 4E 47 0D 0A 1A 0A + random payload (always >= 8 bytes)
        prop::collection::vec(any::<u8>(), 0..1024).prop_map(|mut payload| {
            let mut bytes = vec![0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
            bytes.append(&mut payload);
            (bytes, "image/png")
        }),
        // JPEG: FF D8 FF E0 + random payload (4 bytes header to pass len >= 4)
        prop::collection::vec(any::<u8>(), 0..1024).prop_map(|mut payload| {
            let mut bytes = vec![0xFF, 0xD8, 0xFF, 0xE0];
            bytes.append(&mut payload);
            (bytes, "image/jpeg")
        }),
        // GIF: GIF89a (6 bytes)
        prop::collection::vec(any::<u8>(), 0..1024).prop_map(|mut payload| {
            let mut bytes = b"GIF89a".to_vec();
            bytes.append(&mut payload);
            (bytes, "image/gif")
        }),
        // WEBP: RIFF....WEBP (must be > 11 bytes for detection)
        prop::collection::vec(any::<u8>(), 0..1024).prop_map(|mut payload| {
            let mut bytes = b"RIFF".to_vec();
            bytes.extend_from_slice(&[0x00; 4]); // size placeholder
            bytes.extend_from_slice(b"WEBP");
            bytes.append(&mut payload);
            (bytes, "image/webp")
        }),
        // BMP: BM + padding to ensure >= 4 bytes
        prop::collection::vec(any::<u8>(), 2..1024).prop_map(|mut payload| {
            let mut bytes = b"BM".to_vec();
            bytes.append(&mut payload);
            (bytes, "image/bmp")
        }),
    ]
}

/// Generate random non-image bytes (avoiding all magic headers), always >= 4 bytes.
fn arb_garbage_bytes() -> impl Strategy<Value = Vec<u8>> {
    prop::collection::vec(any::<u8>(), 4..512).prop_filter(
        "must not accidentally start with a valid image magic",
        |bytes| {
            !bytes.starts_with(b"\x89PNG")
                && !bytes.starts_with(b"\xFF\xD8\xFF")
                && !bytes.starts_with(b"GIF8")
                && !(bytes.starts_with(b"RIFF") && bytes.len() > 11 && &bytes[8..12] == b"WEBP")
                && !bytes.starts_with(b"BM")
        },
    )
}

// ── Property Tests ──────────────────────────────────────────

proptest! {
    /// Any bytes with valid image magic headers should be detected.
    #[test]
    fn prop_valid_image_detected((bytes, expected_mime) in arb_image_bytes()) {
        let result = detect_image_mime(&bytes);
        prop_assert!(result.is_some(), "valid image bytes ({} bytes) should be detected", bytes.len());
        prop_assert_eq!(result.unwrap(), expected_mime);
    }

    /// Random non-image bytes should never be detected as images.
    #[test]
    fn prop_garbage_not_detected(bytes in arb_garbage_bytes()) {
        let result = detect_image_mime(&bytes);
        prop_assert!(result.is_none(), "garbage bytes should not be detected as image");
    }

    /// Very short inputs (< 4 bytes) should never be detected.
    #[test]
    fn prop_short_input_rejected(bytes in prop::collection::vec(any::<u8>(), 0..4usize)) {
        let result = detect_image_mime(&bytes);
        prop_assert!(result.is_none(), "input shorter than 4 bytes should be None");
    }

    /// File size boundary: anything over MAX_UPLOAD_SIZE should be rejected.
    #[test]
    fn prop_oversize_rejected(extra in 1..1024usize) {
        let size = MAX_UPLOAD_SIZE + extra;
        prop_assert!(size > MAX_UPLOAD_SIZE);
    }

    /// Any generated safe filename should not contain path separators.
    #[test]
    fn prop_filename_has_no_separators(seq in 1..10000u32, uuid_prefix in "[a-f0-9]{8}") {
        let filename = format!("image_{}_{}.png", seq, uuid_prefix);
        prop_assert!(!filename.contains(".."), "filename must not contain ..");
        prop_assert!(!filename.contains('/'), "filename must not contain /");
        prop_assert!(!filename.contains('\\'), "filename must not contain \\");
    }
}
